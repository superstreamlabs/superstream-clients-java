package ai.superstream.agent;

import ai.superstream.util.SuperstreamLogger;
import net.bytebuddy.asm.Advice;

/**
 * Intercepts {@code KafkaProducer.close(..)} so that Superstream stops collecting
 * metrics and sending statistics for that producer instance after the
 * application has closed it.
 */
public class KafkaProducerCloseInterceptor {

    // Must be non-private because instrumented KafkaProducer.close() accesses this field via generated bytecode.
    public static final SuperstreamLogger logger = SuperstreamLogger.getLogger(KafkaProducerCloseInterceptor.class);

    @Advice.OnMethodEnter
    public static void onEnter(@Advice.This Object producer) {
        if (KafkaProducerInterceptor.isDisabled()) {
            return;
        }

        // Delegate to the main interceptor helper which handles thread-safety and
        // registry updates.  We log only the first successful deactivation to
        // avoid duplicate messages when close() delegates internally.
        try {
            // KafkaProducer has three close(...) overloads that delegate to each other
            // (close(), close(Duration), close(long, TimeUnit)).  Our agent advice is
            // woven into *all* of them, so this method is invoked once per layer of
            // delegation.  We therefore rely on markProducerClosed() to tell us
            // whether this is the *first* invocation for the given producer object
            // and suppress further logging when it returns false.
            KafkaProducerInterceptor.markProducerClosed(producer);
            
        } catch (Throwable ignored) {
            // We swallow any error so that we never affect the application's own
            // close() behaviour.
        }
    }
} 